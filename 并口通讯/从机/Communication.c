
#include "Communication.h"
u8 R_SendMode;
u8 R_SendCnt;
unsigned char R_RecData1,R_RecData2;
unsigned char R_SendData1,R_SendData2;
bit Flg_PinCS;
bit Flg_ToSend;

void RecData()//
{
	static unsigned char R_RecMode;
	static unsigned char R_RecDelay;
	if(Pin_Cs==1)
		{
		//输入
		P1M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P1M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
		//输入
		P3M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P3M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);		
		//输入
		P5M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P5M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);		
		}	
	if(Pin_RW==0)
		{
		return;	//主机在读状态,退出
		}
	P1=0xff;
	P5=0xff;		
	switch(R_RecMode)
	{
		case 0://接收第一个数据
			if(Pin_Cs==1)//片选无效，等待接收第一个数据
				{
				if(Flg_PinCS==0)
					{
					R_RecMode=1;//接收完第一个数据
					R_RecDelay=0;	
					}	
				Flg_PinCS=1;	
				}
				else//片选有效，读取数据
					{
					if(Flg_PinCS==0)
						{
						
						}
					R_RecData1=ReadPin();//读取并口数据			
					Flg_PinCS=0;		
					}
						
			break;	
		case 1:
//			R_RecDelay++;
//			if(R_RecDelay==5)
//				{
//				R_RecMode=0;//等待时间超时，返回等待接收第一个数据	
//				}
			if(Pin_Cs==1)//片选无效，等待
				{	
				Flg_PinCS=1;	
				}	
				else//片选有效
					{
					R_RecMode=2;//准备接收第二个数据
					Flg_PinCS=0;	
					}		
			break;
		case 2://接收第二个数据
			R_SendMode=0;
			if(Pin_Cs==1)//片选无效，等待接收第一个数据
				{
				if(Flg_PinCS==0)
					{
					R_RecMode=0;//接收完第二个数据返回等待接收第一个数据
					R_RecDelay=0;
					R_SendMode=0;	
					}	
				Flg_PinCS=1;	
				}
				else//片选有效，读取数据
					{
					if(Flg_PinCS==0)
						{
						
						}
					R_RecData2=ReadPin();//读取并口数据			
					Flg_PinCS=0;		
					}			
			break;	
		default:
			
			break;	
										
	}
}
void SendData(unsigned char Data1,Data2)
{

	if(Pin_Cs==1)
		{
			//输入
		P1M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P1M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
		//输入
		P3M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P3M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);		
		//输入
		P5M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P5M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);		
		}	
	if(Pin_RW==1)
		{
		return;	//主机在读状态,退出
		}
	if(Pin_Cs==1)
		{
			//输入
		P1M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P1M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
		//输入
		P3M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P3M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);		
		//输入
		P5M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P5M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);		
		}
		else
			{
		//输出
		P1M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P1M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
		//输出
		P5M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
		P5M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);			
			}
						
	if(R_SendCnt)
		{
		R_SendCnt--;	
		}
	switch(R_SendMode)
	{
		case 0:
			if(Pin_Cs==1)//片选无效，等待接收第一个数据
				{
				if(Flg_PinCS==0)
					{
					R_SendMode=1;//接收完第一个数据
					}	
				Flg_PinCS=1;	
				}
				else//片选有效，读取数据
					{
					if(Flg_PinCS==0)
						{
						 
						}
					Flg_ToSend=1;	
					WritePin(Data1);//发送第一个数据	
					Flg_PinCS=0;		
					}
			break;
		case 1://数据保持2个单位时间
			if(Pin_Cs==1)//片选无效，等待接收第一个数据
				{
				if(Flg_PinCS==0)
					{
					R_SendMode=0;//接收完第二个数据
					WritePin(0xff);
					}	
				Flg_PinCS=1;	
				}
				else//片选有效，读取数据
					{
					if(Flg_PinCS==0)
						{
						
						}
					WritePin(Data2);//发送第一个数据	
					Flg_PinCS=0;	
					Flg_ToSend=0;	
					}
			break;	
		case 2://片选保持2个单位时间
					
			if(R_SendCnt==0)
				{
				R_SendMode=0;
				R_SendCnt=2;		
				}
			break;

		default:
			break;										
	}
}
void WritePin(unsigned char R_Data)
{
	if(R_Data&0x01)
		{
		Pin_Bit0=1;	
		}
		else
			{
			Pin_Bit0=0;	
			}
	if(R_Data&0x02)
		{
		Pin_Bit1=1;	
		}
		else
			{
			Pin_Bit1=0;	
			}
	if(R_Data&0x04)
		{
		Pin_Bit2=1;	
		}
		else
			{
			Pin_Bit2=0;	
			}
	if(R_Data&0x08)
		{
		Pin_Bit3=1;	
		}
		else
			{
			Pin_Bit3=0;	
			}
	if(R_Data&0x10)
		{
		Pin_Bit4=1;	
		}
		else
			{
			Pin_Bit4=0;	
			}
	if(R_Data&0x20)
		{
		Pin_Bit5=1;	
		}
		else
			{
			Pin_Bit5=0;	
			}
	if(R_Data&0x40)
		{
		Pin_Bit6=1;	
		}
		else
			{
			Pin_Bit6=0;	
			}
	if(R_Data&0x80)
		{
		Pin_Bit7=1;	
		}
		else
			{
			Pin_Bit7=0;	
			}									
}

unsigned char ReadPin()
{
	unsigned char R_temp=0;
	if(Pin_Bit0)
		{
		R_temp|=0x01;	
		}
	if(Pin_Bit1)
		{
		R_temp|=0x02;	
		}
	if(Pin_Bit2)
		{
		R_temp|=0x04;	
		}
	if(Pin_Bit3)
		{
		R_temp|=0x08;	
		}
	if(Pin_Bit4)
		{
		R_temp|=0x10;	
		}
	if(Pin_Bit5)
		{
		R_temp|=0x20;	
		}
	if(Pin_Bit6)
		{
		R_temp|=0x40;	
		}
	if(Pin_Bit7)
		{
		R_temp|=0x80;	
		}
	return 	R_temp;				
}
void SetPin()
{
	//输出
	P0M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P0M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输入
	P0M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P0M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	
	//输出
	P1M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P1M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输入
	P1M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P1M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	
	//输出
	P2M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P2M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输入
	P2M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P2M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	
	//输出
	P3M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P3M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输入
	P3M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P3M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输出
	P4M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P4M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输入
	P4M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P4M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	
	//输出
	P5M0|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P5M1&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);
	//输入
	P5M0&=~(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);	
	P5M1|=(0x01|0x02|0x04|0x08|0x10|0x20|0x40|0x80);					
}